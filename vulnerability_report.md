#Vulnerability Report
#### Mike Harrison
#### with additonal help from Rick Tesmond

### Oct 2016

## Vulnerability - A1 Injection
In views.py upload function there a form upload. However it directly executes SQL commands.
```
            curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
```

## Repair
Since the above code excutes directly, to fix the vulnerability we can use the orm to make sure the data passed it cleaned.
We replace the above code with
```
            file = File(
            name = name,
            path = upload_path,
            project = proj
            )
            file.save()
```

This uses django's SQL ORM.

## Vulnerability - A2 Broken Auth
I was able to login by setting the html as is_superuser using some input tags.
```
<input type="checkbox" name="is_superuser"> and <input type="checkbox" name="is_staff">
```
This is because this uses an excludes
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

## Repair
Instead of using a excludes blacklist we can switch to a whitelist that allows only certain fields.
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        fields = ('username', 'first_name', 'last_name', 'email', 'password')
```

## Vulnerability - A3 XSS
There are multiple isntances of places that allow people to use javapscript or html to entered
deginsated by the |safe within the templates.
We were able to manipulate html by running script commands such as `name"><script>alert("HAHAHAHAH")</script>` in many of the fields to create a screen alert.

## Repair
The best way to fix this is to not allow the safe option on the template.
There is also the settings option for SECURE_BROWSER_XSS_FILTER to true in configuration that helps proctect against XSS.

## Vulnerability -A4 Insecure DOR
There are a number of sites that one can access but adjusting the url.
Such as the tast_edit/15. These areas are accessible without any creditals.

## Repair
The repair for this would be to have this views be secured by using login requred decorators.

```
@login_required(login_url='/login')
def task_edit(request, project_id, task_id):

    proj = Project.objects.get(pk=project_id)
    task = Task.objects.get(pk=task_id)
```

## Vulnerability - A5 Security Misconfiguration
There is a security misconfiguration by typing in a bad url. This returned a django debug error with
system information.
This gave me a list of urls to try including admin and [name-'index'] etc.

## Repair
In settings.py we change DEBUG=False and TEMPLATE_DEBUG=FALSE
Also the secret_key is not stored in an environmental variable.

## Vulnerability A6 Sensitive Data Exposure
I found routes for exposure through the site's multiple for fields that effect passwords. Since the sites' current hashing algorithm does not salt passwords, we were able to exploit the passwords stored in the database by entering `SELECT * FROM auth_user`. Although it was beyond us, the unsalted passwords are much easier to de-hash.

By exploiting exposure, we gained access to all of the users' passwords from the database.

## Repair
We fixed the password hashing vulnerability by changing the default hashing algorithm `django.contrib.auth.hashers.MD5PasswordHasher` with a more complicated hashing algorithm, like BCryptPasswordHasher that is already salted (`django.contrib.auth.hashers.BCryptPasswordHasher`). Also storing the `PASSWORD_HASHERS` in the virtualenv will help make getting the password even more difficult.

## Missing Function Level Access Control
There are vulnerabilities for MFLAC in the settings.py `manage_groups` view. The view does specify level control AFTER a user already has access to some managerial rights.

So by being signed-in, we were able to access `post` rights in regards to group management; this can be made much more easily if you set yourself to superuser status (see Broken Auth).

## Repair
In the `manage_groups` view:
```
def manage_groups(request):
    user = request.user
    if user.is_authenticated():
        user_list = User.objects.order_by('date_joined')
        if request.method == 'POST':
            post_data = request.POST.dict()
            accesslevel = post_data["accesslevel"].strip()
```
we included another conditional statement that checks if a user is 1) authentication is `True` and 2) if a user has managerial rights before they have access to the post request:
```
def manage_groups(request):
    user = request.user
    if user.is_authenticated():
        logged_in = True
        user_list = User.objects.order_by('date_joined')
        if user.has_perm('can_manage_group'):
            if request.method == 'POST':
                post_data = request.POST.dict()
```
## Cross Site Request Forgery
Found exposure to CSRF attacks on many of the forms on the site and the profile view. In views.py,
```
@csrf_exempt
def profile_by_id(request, user_id):
    user = User.objects.get(pk=user_id)
```
is vulnerable to csrf attacks due to the @csrf decorator, which exludes that view from requiring djangos built in csrf validation to view. Many of the form templates also lacked the `{% csrf_token %}` flag, which leaves the sensitive information open to CSRF attacks.
By exploiting CSRF we were able to redirect the save button on the profile page to redirect to a different page by including an `<a href>` tag around the button.

### Repair
We first removed the `@csrf_exempt` decorator from the profile_by_id view, and on the templates that lacked the `{% csrf_token %}` tag; we added on that tag. For example, on the change_password.html template:
```
<form method="post" role="form">
    {% csrf_token %}
      <div class="form-group col-lg-7 col-sm-7">
          <label >Old Password</label>
          <input type="password" name="old_password" class="form-control">
          <label >New Password</label>
          <input type="password" name="new_password" class="form-control">
          <label >New Password (Confirm)</label>
          <input type="password" name="confirm_password" class="form-control">
          <hr>
          <button type="submit" class="btn btn-info">Save</button>
      </div>
</form>
```

