
#Reviewing Nvisium site for vulnerablilites

#David Flegal

##A1: SQL Injection

For the SQL injection I had found where form data is taken in but not cleaned properly. Since debug is turned on it was easy to find a route with the name of upload. Also, them having a "file name" text field on that particular view was appearant that this is where SQL injection would be easiest. In the source code you could look at where this input is taken in and find the correct format that needed to go into the text input.
To combat this, all you would need to do is use the ORM. The ORM provides a layer between the form input and the actual SQL code so the user can not just input SQL commands into a text field.

Where the code was vulnerable: views.py line 183
```               curs = connection.cursor()
                curs.execute(
                    "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                    (name, upload_path, project_id))
```


In the file name field you would type in something like
```
`test_pic', (select password from auth_user where username = admin), 9);--`
```

To fix this one would need to replace the above code in views.py with:
```
                file = File(
                name = name,
                path = upload_path,
                project = proj)
```
                    

##A2: Broken Auth


For the broken auth, the deisngers had forgotten to exclude permissions fields from their forms. This allows user to easily create a form through the Chrome console, to let themselves become 'superusers'while creating a new user in "/taskManager/register/". With this you would be able to get a authorized cookie and affect the acutla user model to have all permissions and sign in as an admin.
To fix this you can add 'is_superuser' and 'is_staff' to the excluded fields in the form, so these attributes would not be an option to change even if someone adds a field in the html.
Also, the designers have opted to use cookie storage for security. It would not be too difficult for someone to get the key stored in a cookie. Using a different method would be advisable.

The problem can be found in forms.py line 71: 
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

To resolve the issue here you can add these two to excluded fields as such:
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active', 'is_superuser', 'is_staff']
```

##A3:XSS

For the XSS security flaw, the creator is using '|safe' in an input field. This allows a user to write javascript into the input and do whatever he wants. To work around this one would need to remove the '|safe' from the code.

For instance in a text input field one could write
```
prompt('Type in your password to continue')
```
Then the user will have given away the password as that prompt script will run because of the  vulnerablility.

This flaw was found in 'base_backend.html' in the templates directory. All you would need to do in this case is 'ctr-f' for all the '|safe' instances and remove them from the code.

##A4: Insecure DOR
This is a pretty bad one. The creator has no checks to see if the user is authenticated or what projects are assigned to them. The first thing you need to do is use the request.user and run it through Django's is_authenticated() function to make sure the auser has been logged in. Also, the views are collecting the projects in a bad way. Instead of querying them by pk, you should get them out by the DB's foreign keys that are linked speciacally to that user. This way only the projects assigned to that user will pop up.

In views.py there is what seems to be at least 12 instances where the user is not being authenticated. The first thing a view should do before displaying and moving data around is run the code:
```
if request.user.is_authenticated()
```

And only continue if this returns true. And then to check what projects belong to the logged in user, you can query the DB by:
```
Projects.objects.filter('user_assigned' = request.user)
```

For example in this view from line 312 in views.py
```
def task_complete(request, project_id, task_id):
    proj = Project.objects.get(pk=project_id)
    task = Task.objects.get(pk=task_id)
    if proj is not None:
        if task is not None and task.project == proj:
            task.completed = not task.completed
            task.save()
    return redirect('/taskManager/' + project_id)
```

Should look more like:
```
def task_complete(request, project_id, task_id):
	user = request.user()
	if user.is_authenicated():
		#Here we will make sure the logged in user is part of this project
	    proj = Project.objects.get(pk=project_id)
	    if user in proj.users_assigned:
		    task = Task.objects.get(pk=task_id)
		    if proj is not None:
		        if task is not None and task.project == proj:
		            task.completed = not task.completed
		            task.save()
		    return redirect('/taskManager/' + project_id)
		else:
			return redirect('/')
	else:
		return redirect('/')
```


#A5: Misconfig


This was an easy one. Django debugs have been set to true during production. So because of this the user is able to see much information like the url routes and what not. All Django errors will be shown to the user. To fix this you just need to set Debug and Template Debug to false. I am leaving it on for now while I do these assignments.

This can be fixed in settings.py line 29 and 30
```
DEBUG = True
TEMPLATE_DEBUG = True
```
To:
```
DEBUG = False
TEMPLATE_DEBUG = False
```

#A6: Exposure


This site is using a bad hashing algorithm. This algorithm is known to be easily cracked. (So why does Django even support it?). A user, if they knew what they were doing, would be able to get passwords unhashed and login. To fix this we set the hasinh algorithm to a different one.

This can be seen and fixed in settings.py line 102
```
PASSWORD_HASHERS = ['django.contrib.auth.hashers.MD5PasswordHasher']
```
Can be changed to:
```
PASSWORD_HASHERS = ['django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher']
```


#A7: Access


The user is being aiuthenticated but not checking for permissions. This would allow any logged in user to access information that is only supposed to be for a user with specific permission. To fix this we use user.has_perm() on top of is_authenicated().

For example the view fromviews.py in on line 112
```
def manage_groups(request):

    user = request.user


    user_list = User.objects.order_by('date_joined')

    if request.method == 'POST':

        post_data = request.POST.dict()

        accesslevel = post_data["accesslevel"].strip()

        if accesslevel in ['admin_g', 'project_managers', 'team_member']:
```
Needs to be changed as such:
```
def manage_groups(request):

    user = request.user

    if user.is_authenticated() and user.has_perm():

        user_list = User.objects.order_by('date_joined')

        if request.method == 'POST':

            post_data = request.POST.dict()

            accesslevel = post_data["accesslevel"].strip()

            if accesslevel in ['admin_g', 'project_managers', 'team_member']:
```

A8: CSRF


For CSRF the creator for some reason has added a csrf_exempt decorator to many of the views. This allows someone from another browser to create a form with the 'action' being the same as the url of the real site, and add anyinfo they want to the site. This is bad. So we need to get rid of the 'csrf_exempt' decorators and make sure we have our csrf token in the forms.

In any of the templates where a form is being used:
```
{ csrf token }
```
needs to be placed inside the html form tags before the form is created.

In views.py here is an example of a view having the decorator:
```
@csrf_exempt
def change_password(request):

    if request.method == 'POST':
        user = request.user
        old_password = request.POST.get('old_password')
        new_password = request.POST.get('new_password')
        confirm_password = request.POST.get('confirm_password')

        if authenticate(username=user.username, password=old_password):
            if new_password == confirm_password:
                user.set_password(new_password)
                user.save()
                messages.success(request, 'Password Updated')
            else:
                messages.warning(request, 'Passwords do not match')
        else:
            messages.warning(request, 'Invalid Password')

    return render(request,
                  'taskManager/change_password.html',
                  {'user': request.user})
```
You just need to get rid of that decorator:
```
def change_password(request):

    if request.method == 'POST':
        user = request.user
        old_password = request.POST.get('old_password')
        new_password = request.POST.get('new_password')
        confirm_password = request.POST.get('confirm_password')

        if authenticate(username=user.username, password=old_password):
            if new_password == confirm_password:
                user.set_password(new_password)
                user.save()
                messages.success(request, 'Password Updated')
            else:
                messages.warning(request, 'Passwords do not match')
        else:
            messages.warning(request, 'Invalid Password')

    return render(request,
                  'taskManager/change_password.html',
                  {'user': request.user})

```


