#Reviewing Nvisium site for vulnerablilites

#David Flegal

##A1: SQL Injection

For the SQL injection I had found where form data is taken in but not cleaned properly. Since debug is turned on it was easy to find a route with the name of upload. Also, them having a "file name" text field on that particular view was appearant that this is where SQL injection would be easiest. In the source code you could look at where this input is taken in and find the correct format that needed to go into the text input.
To combat this, all you would need to do is use the ORM. The ORM provides a layer between the form input and the actual SQL code so the user can not just input SQL commands into a text field.

Where the code was vulnerable: views.py line 183
```               curs = connection.cursor()
                curs.execute(
                    "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                    (name, upload_path, project_id))
```


In the file name field you would type in something like
```
`test_pic', (select password from auth_user where username = admin), 9);--`
```

To fix this one would need to replace the above code in views.py with:
```
                file = File(
                name = name,
                path = upload_path,
                project = proj)
```
                    

##A2: Broken Auth


For the broken auth, the deisngers had forgotten to exclude permissions fields from their forms. This allows user to easily create a form through the Chrome console, to let themselves become 'superusers'while creating a new user in "/taskManager/register/". With this you would be able to get a authorized cookie and affect the acutla user model to have all permissions and sign in as an admin.
To fix this you can add 'is_superuser' and 'is_staff' to the excluded fields in the form, so these attributes would not be an option to change even if someone adds a field in the html.
Also, the designers have opted to use cookie storage for security. It would not be too difficult for someone to get the key stored in a cookie. Using a different method would be advisable.

The problem can be found in forms.py line 71: 
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

To resolve the issue here you can add these two to excluded fields as such:
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active', 'is_superuser', 'is_staff']
```

A3:XSS

For the XSS security flaw, the creator is using '|safe' in an input field. This allows a user to write javascript into the input and do whatever he wants. To work around this one would need to remove the '|safe' from the code.

For instance in a text input field one could write
```
prompt('Type in your password to continue')
```
Then the user will have given away the password as that prompt script will run because of the  vulnerablility.

This flaw was found in 'base_backend.html' in the templates directory. All you would need to do in this case is 'ctr-f' for all the '|safe' instances and remove them from the code.

A4:
This is a pretty bad one. The creator has no checks to see if the user is authenticated or what projects are assigned to them. The first thing you need to do is use the request.user and run it through Django's is_authenticated() function to make sure the auser has been logged in. Also, the views are collecting the projects in a bad way. Instead of querying them by pk, you should get them out by the DB's foreign keys that are linked speciacally to that user. This way only the projects assigned to that user will pop up.

In views.py there is what seems to be at least 12 instances where the user is not being authenticated. The first thing a view should do before displaying and moving data around is run the code:
```
if request.user.is_authenticated()
```

And only continue if this returns true. And then to check what projects belong to the logged in user, you can query the DB by:
```
Projects.objects.filter('user_assigned' = request.user)
```



