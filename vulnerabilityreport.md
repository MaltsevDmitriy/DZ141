Vulnerability Report
Reviewer 1: Ted Callahan

Reviewer 2: Rick Valenzuela

Date: February 1st, 2017

Reviewing nVisium Task Manager

Vulnerability 1
Exposure
We found an instance of [vulnerability 1] by typing some relevant code into some vulnerable field OR by doing some edge-case thing.

By exploiting [this vulnerability], we were able to retrieve XYZ attributes from the site / access to some unauthorized part of the site / something else valuable.

Repair
problem_file1.py and problem_file2.py contained the vulnerability. We were able to fix the first with the following adjustment(s):

problem_file1.py

Some body of relevant code that solves our problem
problem_file2.py


Vulnerability 1
Exposure
We found an instance of SQL Injection vulnerability in the file upload form (line 183 in views.py).

By exploiting this problem, we are able to perform SQL injection and retrieve data or drop tables from the database.

Repair
Rather than use a formatted SQL command with input from the form, the site should use the DJANGO ORM to create a File object instance for addition to the databse.

Problem Code (Lines 182 - 185, views.py):
curs = connection.cursor()
curs.execute(
    "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
    (name, upload_path, project_id))

Solution:
file = File(
name = name,
path = upload_path,
project = proj)

file.save()

Vulnerability 2
Exposure
Various upload functions call the store_uploaded_file() funtion at line 24 of msc.py.  This function passes a given filename to the os.system function giving a user the potential to pass in shell commands as a filename.

Repair
Do not allow the user to pass in a file name.  Give the file a randomly generated name, there is no reason for a user to give a file a name for use in the application.

Instead, create a File instance and save the file instance in the database.  The user can give the File object a name, thus preventing any need for calling os.system or any commands that rely on command line commands.


Vulnerability 3
Exposure
The User registration form (class UserForm) as defined in forms.py (lines 71 - 75) is insecure because it does not explicitly state which fields are allowed.  A user could add fields for other attributes of the Django user model (such as is_superuser).

By exploiting this problem, we are able to add form fields to the User registration form to edit user attributes on the Django model.

Repair
Instead of a partial exclude list of fields, use the fields attribute in the Meta class to explicitly declare which fields should be in the form.

Problem Code (line 75 in forms.py):
exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']

Solution:
fields = ['username', 'email', 'first_name', 'last_name', 'password']


Vulnerability 4
Something to do with:
SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"


Vulnerability 5
Exposure
The template base_backend.html inserts the username with a safe flag.  This allows the potential for a JS script as a username to be rendered to the page, causing it to be run because it will not be escaped.

Repair
Instead of declaring safe output with the safe flag, do not do that.

Problem Code (line 58 of base_backend.html):
<span class="username"><i class="fa fa-user fa-fw"></i> {{user.username|safe}}</span>

Solution:
<span class="username"><i class="fa fa-user fa-fw"></i> {{user.username}}</span>


Vulnerabilty 6
Exposure
Website is generally at-risk for Cross Site Scripting attacks.  By turning on Django's SECURE_BROWSER_XSS_FILTER setting, Django will add X-XSS-Protection to all responses.  The browser will then automatically block all XSS attacks it can detect.

Repair
Set SECURE_BROWSER_XSS_FILTER = True in settings.py


Vulnerability 7
Exposure
All CRUD operations are vulnerable to Insecure Direct Object Reference (IDOR).  Basically, in order to prevent unauthorized users or users with inappropriate permissions, the site should require all proper credentials and permissions from an user before a CRUD operation is performed.

For Class Based Views, use the LoginReqiuredMixin and PermissionRequiredMixin

Repair
Apply @login_required and @permission_required decorators for any function in views.py that performs a CRUD operation.

Problem Code functions listed from views.py:
 - manage_products
 - manage_groups
 - upload
 - task_create
 - task_edit
 - task_delete
 - project_delete
 - project_edit
 - project_create
 - note_create
 - note_edit
 - note_delete

Solution:
### For Function Views:
from django.contrib.auth.decorators import permission_required, login_required

@login_required
@permission_required
def function_view_with_CRUD(request):


### For Class Based Views:
from django.contrib.auth.mixins import PermissionRequiredMixin, LoginRequiredMixin

class ClassBasedCRUDView(LoginRequiredMixin, PermissionRequiredMixin, ClassView):
