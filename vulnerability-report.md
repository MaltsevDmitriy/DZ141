#Vulnerability Report

####Reviewer 1: Jordan Schatzman

####Reviewer 2: Joey Derosa

####Date: February 4, 2017 

##Revieiwing nVisium Task Manager

##Vulnerability 1 (A1 - Injection)

##Exposure

We found an instance of sql injection vulnerability.  To exploit this, I navigated to the file upload page for a project and entered in the following file path: 'testPic',(select password from auth_user where username='admin'),8);--''.  This was supposed to reveal the admin password but I was not able to locate it.

##Repair

To fix this vulnerability, use the Django ORM which handles malicious form inouts.  Avoid using direct ORM methods like curs.execute().


##Vulnerability 2 (A2 - Broken Auth)

##Exposure

A user is able to grant himself admin priveliges.  He can do this because the is_superuser field is not blacklisted in the user form.  By manually changing the html, he can submit the form and make himself an admin.

##Repair

It is better to use include instead of exclude for forms.  This makes it easier to restrict the fields the user can submit.  In this case if it is necessary to use blacklist instead of whitelist, we need to add the 'is_staff' and 'is_superuser' fields.


##Vulnerability 3 (A3 - XSS)

##Exposure

In the backend/base.html, the user's username is rendered with "user.username|safe".  This means that this value is not rednered back to the client as HTML or JS as opposed to just HTML.  A user can assign any of his attributes to a string like 

```
<script>alert("This is annoying")</script>"

```

This will be run as JS anytime a page is refreshed with this user logged in.

##Repair

To prevent this from happening, remove the "|safe" and consider using X-XSS-Protection in webserver configuration as well as setting SECURE_BROWSER_XSS_FILTER to true.  This is present in several places in the application.


##Vulnerability 4 (A4 - Insecure DOR)

##Exposure

When trying to edit tasks, I could simply alter the task ID parameter in the URL to take me to the edit task page for any page that I wanted regardless of who the owner of that project was.

##Repair

To ensure that I cannot edit any task I want to, I should valdate user permsissions for every function that reads for writes from the database.  There are some handy builtins such as user.is_authenticated() that can be helpful here.  Login mixins would be good as well.

##Vulnerability 5 (A5 - Misconfig)

##Exposure

In settings.py, the debug flag is set to true.  As a result, an attacker is able to see detailed information about the app even by doing simple tasks like entering an invalid URL.

##Repair

To resolve this issue, just set the debug flag to false in settings.py.  This will result in more generic errors messages returned to the client, hiding the details of an application's structure.


##Vulnerability 6 (A6 - Exposure)

##Exposure

The passwords stored in the database are hashed, but the algorithm used for hashing is weak.  An attacker with necessary hardware is able to test millions of passwords per second against this system since the hashing algorithm is so quick.

##Repair

Instead of using the MD5 algorithm, we should consider using stronger algorithms like bcrypt or PBKDF2.  This can be done in settings.py by removing:

```
PASSWORD_HASHERS = [

'django.contrib.auth.hashers.MD5PasswordHasher'

]

```
and replacing it with (among other options):

```

PASSWORD_HASHERS = [

'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher'

]

```

In this case, even if your database is compromised, an attacker cannot determine user passwords or other hashed values since running this hashing algorithm takes up to several seconds.


##Vulnerability 7 (A7 - Access)

##Exposure

The manage_groups method in views.py is not correctly secured.  Initially, a check is done to see if the user is authenticated but no further check is done to see if the user has permissions to post.

##Repair

To fill this security gap, an additional authorization check should be done before allowing a POST reqeust to be made.


##Vulnerability 8 (A8 - CSRF)

##Exposure

The profile_by_id method in view.py uses the csrf_exempty decorator.  When this decorator is used, django will not check for the csrf token for incoming requests.

##Repair

To alleviate this risk, simply remove the decorators wherever they are used.